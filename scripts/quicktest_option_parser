#! /usr/bin/env bash


export SCRIPTS_PATH="${QUICKTEST_PATH}/scripts"
export AWK_FILES_PATH="${SCRIPTS_PATH}/awk"

source "${SCRIPTS_PATH}/quicktest_interface"


#
# This function would set 2 "readonly" global arrays and one "readonly" gloabal var
#
# OPTIONS:
#  All passed arguments in it are keys in this array
#  with value "1"
#
# ARGS:
#  It contains arguments corresponding to set OPTIONS.
#
# ACTION:
#  This is used to distribute various options into separate categories.
#  Options passed belong to a specific niche, so we just set ACTION
#  variable accordingly.
#
#   "TEST":
#     This key is set by default if no other key is set.
#   "SETTINGS":
#     This key is set if some settings, like setting user config files,
#     needs to be done.
#   "INFO":
#     This needs to be set if some information needs to be displayed.
#   "OTHER":
#     This is set if operation being done has nothing to do with
#     default behaviour of program and achieves some side things.
#
#  ACTION are helpful to avoid cluttered code and divides various options
#  into their own categories.
#
parse_options() {

	declare -gA ARGS
	declare -gA OPTIONS
	declare -g ACTION

	# -1 if optional one arg
	# otherwise count of args needed
	local next_is_arg="0"

	local prev_opt
	local is_arg
	local flag_arg_not_found="0"

	ACTION="TEST"

	while [ $# -gt "0" ]
	do
		option=$1 ; shift
		is_arg="0"

		case "${option}" in

			-b|--boilerplate)
				option="--boilerplate"
				OPTIONS["${option}"]="1"
				next_is_arg="1"
				;;
			-gbc|--get-boilerplate-code)
				option="--get-boilerplate-code"
				OPTIONS["${option}"]="1"
				ACTION="OTHER"
				next_is_arg="1"
				;;
			-h|--help)
				option="--help"
				OPTIONS["${option}"]="1"
				ACTION="INFO"
				next_is_arg="0"
				;;
			-i|--instance)
				option="--instance"
				OPTIONS["${option}"]="1"
				next_is_arg="1"
				;;
			-mb|--modify-boilerplate)
				option="--modify-boilerplate"
				OPTIONS["${option}"]="1"
				ACTION="SETTINGS"
				next_is_arg="-1"
				;;
			-mucf|--modify-user-config-file)
				option="--modify-user-config-file"
				OPTIONS["${option}"]="1"
				ACTION="SETTINGS"
				next_is_arg="-1"
				;;
			-n|--new)
				option="--new"
				OPTIONS["${option}"]="1"
				next_is_arg="0"
				;;
			-r|--recover)
				option="--recover"
				OPTIONS["${option}"]="1"
				ACTION="OTHER"
				next_is_arg="0"
				;;
			-ra|--register-action)
				option="--register-action"
				OPTIONS["${option}"]="1"
				ACTION="SETTINGS"
				next_is_arg="2"
				;;
			-rma|--remove-action)
				option="--remove-action"
				OPTIONS["${option}"]="1"
				ACTION="SETTINGS"
				next_is_arg="1"
				;;
			-s|--save-to-path)
				option="--save-to-path"
				OPTIONS["${option}"]="1"
				ACTION="OTHER"
				next_is_arg="1"
				;;
			-sb|--show-boilerplates)
				option="--show-boilerplates"
				OPTIONS["${option}"]="1"
				ACTION="INFO"
				next_is_arg="0"
				;;
			-sh|--show-history)
				option="--show-history"
				OPTIONS["${option}"]="1"
				ACTION="INFO"
				next_is_arg="-1"
				;;
			-sucf|--show-user-config-files)
				option="--show-user-config-files"
				OPTIONS["${option}"]="1"
				ACTION="INFO"
				next_is_arg="0"
				;;
			-uc|--user-config)
				option="--user-config"
				OPTIONS["${option}"]="1"
				next_is_arg="1"
				;;
			-v|--verbose)
				option="--verbose"
				OPTIONS["${option}"]="1"
				ACTION="INFO"
				next_is_arg="0"
				;;
			*)
				is_arg="1"

				if [ "${next_is_arg}" -eq "0" ] ; then
					usage
					return 1
				else
					if [ "${next_is_arg}" -eq "-1" ] ; then
						next_is_arg="0"
					else
						next_is_arg="$(expr "${next_is_arg}" - 1)"
					fi

					if [ -n "${ARGS["${prev_opt}"]}" ] ; then
						ARGS["${prev_opt}"]="${ARGS["${prev_opt}"]} ${option}"
					else
						ARGS["${prev_opt}"]="${option}"
					fi

					flag_arg_not_found="0"
				fi

				;;
		esac

		if [ "${flag_arg_not_found}" -eq "1" ] ; then
			usage
			return 1
		fi

		if [ "${next_is_arg}" -gt "0" ] ; then
			flag_arg_not_found="1"
			# will be set to 0 if found
		fi

		if [ "${is_arg}" -eq "0" ] ; then
			prev_opt="${option}"
		fi

	done


	if [ "${flag_arg_not_found}" -eq "1" ] ; then
		usage
		return 1
	fi


	readonly OPTIONS
	readonly ARGS
	readonly ACTION
}

get_arg() {
	local option=$1 ; shift
	local arg_pos=$1 ; shift

	awk -F' ' -v arg_pos="${arg_pos}" '{printf $arg_pos}' <<<"${ARGS["${option}"]}"
}
